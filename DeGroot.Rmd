---
title: "Naive learning"
author: "Raffaele di Costanzo, Wojciech Ma≈õlakiewicz"
date: "3/29/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Some introduction

## Summary of the experimental paper

## Basic model

```{r packages, include=FALSE}
requiredPackages = c("markovchain", "readr","diagram", "wesanderson", "expm") # list of required packages
for(i in requiredPackages){if(!require(i,character.only = TRUE)) install.packages(i)}
for(i in requiredPackages){if(!require(i,character.only = TRUE)) library(i,character.only = TRUE) } 

# Base on:
# 1. Taalaibekova, 2018 example 2.1
# 2. Janpu Hou https://rpubs.com/JanpuHou/326048

# The notation is based on Taalaibekova


# Simulation of the process
# Different type of notation of transaction matrix 
markov_chains_2 <-  function(M, x0, iter ){
  sym <- matrix(0, nrow = nrow(M), ncol =  iter )
  M_to_p_i <- M
  sym[,1] <- x0
    for(i in 2:iter) {
    
    sym[,i] <- M_to_p_i %*% x0 
    M_to_p_i <- M %*% M_to_p_i
  }
  return(sym)
}
```



< description of basic model>

## Extension 1

some description of extension 1  

some equations  

some theoretical results  

some simulation

```{r extension 1 simulation, echo=TRUE}
markov_chains_4 <-  function(M, x0, iter, fA,fB,fC
                             ,noA = N*percA,noB = N*percB,noC = N*percC  ){
  sym <- matrix(0, nrow = nrow(M), ncol =  iter )
  M_to_p_i <- M
  sym[,1] <- x0
  for(i in 2:iter) {
    lA <- sapply(rep(i,noA),fA_con)
    lB <- sapply(rep(i,noB),fB_con)
    lC <- sapply(rep(i,noC),fC_con)
    lambdas = c(lA,lB,lC)
    sym[,i] <- ((1-lambdas)*diag(dim(M)[1]) + lambdas*M_to_p_i) %*% x0 
    M_to_p_i <- M %*% M_to_p_i
  }
  return(sym)
}
```


```{r extension 1, include=FALSE}



make_matrix <- function(dim,vals){
  M = matrix(vals,nrow = dim, byrow = TRUE)
  return(M)
}

trustAA = 3/4
trustAB = 0
trustAC = 1/4

trustBB = 3/4
trustBA = 0
trustBC = 2/8

trustCC = 0
trustCA = 1/5
trustCB = 4/5

percA = 0.3
percB = 0.5
percC = 0.2

N = 100

AA = make_matrix(N*percA,c(rep(trustAA/(N*percA),(N*percA)^2)))
AB = make_matrix(N*percA,c(rep(trustAB/(N*percB),(N*percB)*(N*percA))))
AC = make_matrix(N*percA,c(rep(trustAC/(N*percC),(N*percC)*(N*percA))))

rowA = cbind(AA,AB,AC)

BA = make_matrix(N*percB,c(rep(trustBA/(N*percA),(N*percB)*(N*percA))))
BB = make_matrix(N*percB,c(rep(trustBB/(N*percB),(N*percB)*(N*percB))))
BC = make_matrix(N*percB,c(rep(trustBC/(N*percC),(N*percB)*(N*percC))))

rowB = cbind(BA,BB,BC)

CA = make_matrix(N*percC,c(rep(trustCA/(N*percA),(N*percC)*(N*percA))))
CB = make_matrix(N*percC,c(rep(trustCB/(N*percB),(N*percC)*(N*percB))))
CC = make_matrix(N*percC,c(rep(trustCC/(N*percC),(N*percC)*(N*percC))))

rowC = cbind(CA,CB,CC)

W= rbind(rowA,rowB,rowC)

distA = rbeta(N*percA,1,7)
distB = rbeta(N*percB,7,1)
distC = rbeta(N*percC,7,7)


fA_con = function(i){ return(1 - 0.9/16 *i + runif(1,-0.01,0.01)) }
fB_con = function(i){ return(1 - 0.9/16 *i + runif(1,-0.01,0.01)) }
fC_con = function(i){ return(runif(1,0.6,0.9) ) }

  
X_0 <- c(distA,distB,distC)
t <- 15 # Iteration of interactions 
sym <- as.data.frame(markov_chains_4(W, X_0 ,t,fA_con,fB_con,fC_con))
X_fin = sym[,t]
vacc_0 <- sum(X_0>0.5)/length(X_0)
vacc_fin <- sum(X_fin>0.5)/length(X_fin)


sym[1:(N*percA),t+1] <- rep("Agent A",N*percA)
sym[(N*percA+1):(N*percA+N*percB),t+1] <- rep("Agent B",N*percB)
sym[(N*percA+N*percB+1):(N*percA+N*percB+N*percC),t+1] <- rep("Agent C",N*percC)

#row.names(sym)[1:(N*percA)] <- rep("Agent A",N*percA)
#row.names(sym)[(N*percA+1):(N*percA+N*percB)] <- rep("Agent B",N*percB)
#row.names(sym)[(N*percA+N*percB+1):(N*percA+N*percB+N*percC)] <- rep("Agent C",N*percC)

```

A plot of the extension:

```{r extension 1 plot, echo=FALSE, warning=FALSE}
matplot(t(sym), ylim = c(0,1.4), type = c("b"),pch=1,col = as.factor(sym[,t+1])) #plot
legend("topright", legend = unique(sym[,t+1]), col=1:3, pch=19, bty ="n") # optional legend
```



## Extension 2

> Description, equations etc.

 
## Some summary  
 
summary here
 
## References

1. Ref1 
2. Ref2
...
